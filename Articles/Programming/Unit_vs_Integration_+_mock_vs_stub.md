# Unit vs Integration tests

Важным этапом написания кода является тестирование, значимость которого пропорционально увеличивается вместе с увеличением сложности приложения. 

К плюсам тестирования можно отнести следующие моменты:
* когда пишешь тест, ты смотришь на свой код под другим углом зрения и замечаешь лишние/недостающие моменты - это помогает улучшить структуру
* можно изменять часть функционала, не боясь, что незаметно "испортиться" остальные элементы, что позволяет упростить процесс улучшения отдельных частей кода
* по тестам можно определить что должен делать тестируемый элемент без детального изучения кода
* является одной из самых динамичных составляющих приложения и обладает наиболее консистентными данными об изменениях (та же документация может не учесть последние изменения и не сопровождается автоматической отслеживаемостью)

В зависимости от того, насколько связные объекты тестируются, можно привести следующую классификацию:

1. Unit tests - тесты, которые проверяют независимые от других элементов части кода (например, отдельные функции). Их может быть большое количество.
2. Integration tests - тесты, проверяющие взаимодействие отдельных "единиц"(модулей), например тестируется функция, которая связывает различные модули, код и вызов к базе данных, проверка rest api сервиса, работа с файловой структурой и др.
3. End-to-end tests - последние тесты, но не по значимости, которые проверяют работу всей системы элементов комплексно. 
>Самые затратные в обслуживании. Желательно не использовать их в качестве основной стратегии тестирования. 

Часто данная классификация изображается в виде пирамиды, основание которой unit tests, затем integtation и на вершине end-to-end. 

![](https://github.com/PerminovaAnastasia/Images/blob/master/rules-of-thumb.png)

Данная графическая интерпретация характеризует оптимальное количественное соотношение тестов в приложении.


**Сравнительная характеристика Unit и Integration tests**

| Тест | Что проверяют | Сложность написания | Время вычисления | Зависимости | Назначение | Средства реализации|
| :---        |     :---      |         :--- | :---       |     :---    |         :--- | :---|
| Unit tests   | Небольшие участки кода, реализующие конкретные элементы (небольшие функции)     | Легко пишутся |Очень быстро вычисляются    | Не должны зависеть от внешних элементов   | Проверка корректности логики отдельных частей, показывает изменения о которых "забыли"     | Тестовые фреймворки (Mocha), заглушки (stub, mock, spy)    |
| Integration tests     | Покрывают все части приложения     | Требуют усилий при организации связи элементов      | Медленнее unit tests     | Часто работают с внешними объектами, например с базой данных, файловой системой и др.       | Проверка взаимосвязи различных элементов системы, имитация реальной работы с тестируемой точкой(фокусом)      | Тестовые фреймворки (Mocha)|
| End-to-end tests     | Сценарии, которые максимально приближены к реальной эксплуатации программы   | Требуют еще больших усилий по сравнению с integartion tests| Занимают еще больше времени по сравнению с integartion tests | Проверяется вся система: входные/выходные данные, работа сервера и всего бизнес-слоя |Определение системы зависимостей и подтверждение корректности передачи нужной информации между различными компонентами системы | Тестовые фреймворки Protractor, Selenium|

*** Практическая разница реализации unit и integration test с помощью Mocha

Языки программирования обладают своими средствами, которые позволяют автоматизировать тестирование. Одним из примеров для Node js, может полсужить следующая комбинация фреймворков - Mocha, Chai и Sinon.

Mocha – это фреймворк, содержащий общие функции для тестирования, включая describe и it, а также позволяющая тестировать асинхронно.

Chai – библиотека, которая поддерживает разнообразные функции для проверок. Есть разные «стили» проверки результатов (assert, expect, should).

>Важный момент, который не следует забывать, один тест должен проверять что-то одно. Так, если вы хотите проверить работу сервиса на разном наборе параметров одновременно, стоит их разделить на отдельные блоки. 
>>Поскольку, в случае с указанными выше средствами, если делать несколько assert в одном блоке it, то при обнаружении ошибки в первом, второй так и не выполнится, так как прекращается выполнения блока it.

```Пример:
Необходимо проверить функцию сложения комплексных чисел, которые задаются в виде объекта:
{
	re: number,
	im: number
	}
	
describe("Summarize complex numbers", function() {

  it("Summarize complex numbers", function() {
    let complexNumber = {re:2, im:3};
    assert.equal(sumComplex(complexNumber, 0), complexNumber);
    assert.equal(sumComplex(complexNumber, {re:1, im:4}), {re:3, im:7});
  });

});

Предпочтительный вариант разделить на отдельные блоки it:

describe("Summarize complex numbers", function() {

  it("Summarize complex number with zero", function() {
    let complexNumber = {re:2, im:3};
    assert.equal(sumComplex(complexNumber, 0), complexNumber);
  });
  
  it("Summarize 2 complex numbers", function() {
    let complexNumber = {re:2, im:3};
    assert.equal(sumComplex(complexNumber, {re:1, im:4}), {re:3, im:7});
  });

});

```

[Sinon](http://sinonjs.org) – это библиотека для JavaScript, которая предоставляет функции для эмуляции и проверки требуемого поведения. В ней представлены три вида тестирования с spy, stub и mock. 

Согласно ее документации, можно заметить, что предложенное разделение коррелирует с теми возможностями проверок, которые сопровождают mock и stub в данной библиотеке:

```
let mock = sinon.mock(obj);

let expectation = mock.expects("method");
```
Например, теперь можно проверять следующее:
* expectation.atLeast(number) - минимально ожидаемое количество вызовов
* expectation.atMost(number) - максимально ожидаемое количество вызовов
* expectation.never() - не ожидается быть вызванным
* expectation.once() - ожидается быть вызванным один раз (twice - дважды, thrice - трижды)
* expectation.exactly(number) - ожидается быть вызванным строго заданное число раз
* expectation.withArgs(arg1, arg2, ...) - ожидается быть вызванным с указанными аргументами
* и др.

```
let stub = sinon.stub(object, "method");

или заменить весь объект sinon.stub(object);
```
Приведу основную идею вариативности возможностей:

	 stub.withArgs(2).returns(1);
     
     Или в случае исключительной ситуации
     
     stub.withArgs(1).throws("Error");
     
     И если вызовем, то получим
     stub(); // Ничего не возвращается, не определили поведение
     stub(2); // Вернет 1
     stub(1); // Throws Error

Если необходимая функция используется несколько раз в тестируемом блоке и должна возвращать разные объекты - можно воспользоваться

	stub.onCall(n) - есть еще onFirstCall, onSecondCall, onThirdCall

**И в заключении**

Когда вы покрываете функционал Unit-тестами, стоит обратить внимание на рассматриваемые типы тестовых объектов, поскольку с их помощью можно эффективно проверить ваш код. Так они позволяют:

1. Минимизировать скорость выполнения тестов в сравнении с тестами над реальными объектами 
	>Обращение к базе данных, файловой системе и другие сторонние запросы.
	
2. Запускать тесты независимо от окружения или сопроводительного интерфейса
	>У вас есть тестируемый метод getItem(key), который вместо обращения к базе возвращает объект нужной структуры. Проверяется в данном тесте логика последующей работы функции. В таком случае проверка на машине с отсутствующей базой данных пройдет успешно. 
	Или у вас уже есть большое количество тестов, которые обращаются к базе, и для уменьшения ее загрузки (реальные вызовы оставить для integration tests) можно воспользоваться заглушками.
	Или в случае, когда необходимый метод в стороннем сервисе еще не реализован, но для теста необходимы возвращаемые данные.

3. Устранить сложности при проверке над реальными объектами 
	>Авторизация в приложении через социальную сеть с необходимостью получения токена.

В тоже время, при проверке зависимостей отдельных модулей не обойтись без integration tests, поскольку это упрощает выявление непредвиденных изменений в узловых точках соединения отдельных частей вашего кода.

При реализации тестирования вашего приложения стоит учесть вышеизложенные преимущества данных видов тестирования и найти эффективное пропорциональное соотношение между ними. Что позволит вам быть уверенным в качестве и консистентности итогового продукта в любе время.
