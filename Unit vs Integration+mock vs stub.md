# Unit vs Integration tests

Важным этапом написания кода является тестирование, рост и значимость которого пропорционально увеличивается вместе с увеличением сложности приложения. 

К плюсам тестирования можно отнести следующие моменты:
* является одной из самых динамичных составляющих приложения и обладает наиболее консистентными данными об изменениях (та же документация может не учесть последние изменения и не сопровождается автоматической отслеживаемостью)
* по тестам можно определить что должен делать тестируемый элемент без детального изучения кода
* можно изменять часть функционала, не боясь, что незаметно "испортиться" остальные элементы, что позволяет упростить процесс улучшения отдельных частей кода
* когда пишешь тест, ты смотришь на свой код под другим углом зрения и замечаешь лишние/недостающие моменты - это помогает улучшить структуру

В зависимости от того, насколько связные объекты тестируются, можно привести следующую классификацию:

1. Unit tests - тесты, которые проверяют независимые от других элементов части кода (например, отдельные функции). Их может быть большое количество.
2. Integration tests - тесты, проверяющие взаимодействие отдельных "единиц"(модулей), например тестируется функция, которая связывает различные модули, код и вызов к базе данных, проверка rest api сервиса, работа с файловой структурой и др.
3. End-to-end tests - последние тесты, но не по значимости, которые проверяют работу всей системы элементов комплексно. 
>Самые затратные в обслуживании. Желательно не использовать их в качестве основной стратегии тестирования. 

Часто данная классификация изображается в виде пирамиды, основание которой unit tests, затем integtation и на вершине end-to-end. Данная графическая интерпретация характеризует количественное соотношение тестов в приложении.

**Сравнительная характеристика Unit и Integration tests**

| Тест | Что проверяют | Сложность написания | Время вычисления | Зависимости | Назначение |
| :---        |     :---      |         :--- | :---       |     :---    |         :--- |
| Unit tests   | Небольшие участки кода, реализующие конкретные элементы (небольшие функции)     | Легко пишутся |Очень быстро вычисляются    | Не должны зависеть от внешних элементов   | Проверка корректности логики отдельных частей, показывает изменения о которых "забыли"     | git status    |
| Integration tests     | Покрывают все части приложения     | Требуют усилий при организации связи элементов      | Медленнее unit tests     | Часто работают с внешними объектами, например с базой данных, файловой системой и др.       | Проверка взаимосвязи различных элементов системы, имитация реальной работы с тестируемой точкой(фокусом)      |


# Mocks vs Stubs

Смысл рассматриваемых двух понятий тесно связан при изучении вопроса тестирования элементов кода. Они 
определяются как объекты, которые создаются и используются вместо реальных при написании тестов. 

Являются объектами так называемых Test Doubles. 

Делая попытку их разграничить, я ориентировалась на статью [Mocks Aren't Stubs](https://www.martinfowler.com/articles/mocksArentStubs.html). 

Разделить mocks и stubs можно, ответив на  вопрос "что проверяем?" - состояние или поведение. Если первое - stub, второе - mock.

Сложности проверки mock-объектов возникают в том случае, когда при изменении кода, приходится изменять и сам принцип работы уже написанных моментов. Впрочем, и проверка stub-объектов переписывается в случае изменения оперируемых данных.


*****

Языки программирования обладают своими сопровождающими элементами, которые позволяют автоматизировать тестирование. Примером для Node js могут служить следующие фреймворки - Mocha, Chai, Sinon и др.

Mocha – эта библиотека содержит общие функции для тестирования, включая describe и it.

Chai – библиотека поддерживает разнообразные функции для проверок. Есть разные «стили» проверки результатов (assert, expect, should).

>Важный момент, который не следует забывать, один тест проверяет ровно одну вещь. 
>> Если делать несколько assert в одном блоке it, то при обнаружении ошибки в первом, второй так и не выполнится, так как прекращается выполнения блока it.

[Sinon](http://sinonjs.org) – библиотека для подмены функций заглушками.

Согласно ее спецификации, можно заметить, что предложенное разделение коррелирует с теми возможностями проверок, которые сопровождают mock и stub в данной библиотеке:

```
let mock = sinon.mock(obj);

let expectation = mock.expects("method");
```
Теперь можно проверять следующие моменты:
* expectation.atLeast(number) - минимально ожидаемое количество вызовов
* expectation.atMost(number) - максимально ожидаемое количество вызовов
* expectation.never() - не ожидается быть вызванным
* expectation.once() - ожидается быть вызванным один раз (twice - дважды, thrice - трижды)
* expectation.exactly(number) - ожидается быть вызванным строго заданное число раз
* expectation.withArgs(arg1, arg2, ...) - ожидается быть вызванным с указанными аргументами
* и др.

```
let stub = sinon.stub(object, "method");

или заменить весь объект sinon.stub(object);
```
Приведу основную идею вариативности возможностей:

	 stub.withArgs(2).returns(1);
     
     Или в случае исключительной ситуации
     
     stub.withArgs(1).throws("Error");
     
     И если вызовем, то получим
     stub(); // Ничего не возвращается, не определили поведение
     stub(2); // Вернет 1
     stub(1); // Throws Error

Если необходимая функция используется несколько раз в тестируемом блоке и должна возвращать разные объекты - можно воспользоваться

	stub.onCall(n) - есть еще onFirstCall, onSecondCall, onThirdCall

**Вывод**

Приведенные выше возможности объектов-"заглушек" иллюстрируют предложенное разделение верификации состояния и поведения.



