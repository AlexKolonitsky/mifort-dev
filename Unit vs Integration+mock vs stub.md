# Unit vs Integration tests

Важным этапом написания кода является тестирование, рост и значимость которого пропорционально увеличивается вместе с увеличением сложности приложения. 

К плюсам тестирования можно отнести следующие моменты:
* является одной из самых динамичных составляющих приложения и обладает наиболее консистентными данными об изменениях (та же документация может не учесть последние изменения и не сопровождается автоматической отслеживаемостью)
* по тестам можно определить что должен делать тестируемый элемент без детального изучения кода
* можно изменять часть функционала, не боясь, что незаметно "испортиться" остальные элементы, что позволяет упростить процесс улучшения отдельных частей кода
* когда пишешь тест, ты смотришь на свой код под другим углом зрения и замечаешь лишние/недостающие моменты - это помогает улучшить структуру

В зависимости от того, насколько связные объекты тестируются, можно привести следующую классификацию:

1. Unit tests - тесты, которые проверяют независимые от других элементов части кода (например, отдельные функции). Их может быть большое количество.
2. Integration tests - тесты, проверяющие взаимодействие отдельных "единиц"(модулей), например тестируется функция, которая связывает различные модули, код и вызов к базе данных, проверка rest api сервиса, работа с файловой структурой и др.
3. End-to-end tests - последние тесты, но не по значимости, которые проверяют работу всей системы элементов комплексно. 
>Самые затратные в обслуживании. Желательно не использовать их в качестве основной стратегии тестирования. 

Часто данная классификация изображается в виде пирамиды, основание которой unit tests, затем integtation и на вершине end-to-end. Данная графическая интерпретация характеризует количественное соотношение тестов в приложении.

**Сравнительная характеристика Unit и Integration tests**

| Тест | Что проверяют | Сложность написания | Время вычисления | Зависимости | Назначение |
| :---        |     :---      |         :--- | :---       |     :---    |         :--- |
| Unit tests   | Небольшие участки кода, реализующие конкретные элементы (небольшие функции)     | Легко пишутся |Очень быстро вычисляются    | Не должны зависеть от внешних элементов   | Проверка корректности логики отдельных частей, показывает изменения о которых "забыли"     | git status    |
| Integration tests     | Покрывают все части приложения     | Требуют усилий при организации связи элементов      | Медленнее unit tests     | Часто работают с внешними объектами, например с базой данных, файловой системой и др.       | Проверка взаимосвязи различных элементов системы, имитация реальной работы с тестируемой точкой(фокусом)      |


# Mocks vs Stubs

Mocks и Stubs являются специальными типами объектов, которые реализуют заданные аспекты моделируемой ситуации и используются в проверке работоспособности тестируемого объекта.
> Наряду с вышеуказанными типами, также определены и другие: Dummy, Fake and Spies. Детальное описание которых можно найти в книге [XUnit Test Patterns](http://xunitpatterns.com).

Делая попытку их разграничить, я ориентировалась на статью [Mocks Aren't Stubs](https://www.martinfowler.com/articles/mocksArentStubs.html). 

Разделить stubs и mocks можно, ответив на  вопрос "что проверяем?" - состояние или поведение. Если первое - stub, второе - mock. 
> Например, у нас есть http запрос на сервер, который выполняет следующее:
>1. заходит в базу данных за сведениями
>2. производит манипуляции над полученными данными
>3. сохраняет в базу изменения
>4. отправляют необходимую информацию обратно на сторону клиента. 

>С помощью Stub-объектов можно подменить результат отдельного метода(получение данных из базы) и проверить логику работы сервиса, в том числе можно подменить и функцию сохранения, чтобы не накапливались тестовые данные. А mock-объекты позволяют исследовать последовательность вызовов и их количество. 

Недостатком использования данных объектов является тот факт, что при изменении кода, приходится изменять и уже реализованную логику проверки в тесте.

*****

Языки программирования обладают своими средствами, которые позволяют автоматизировать тестирование. Примером для Node js могут служить следующие фреймворки - Mocha, Chai, Sinon и др.

Mocha – эта библиотека содержит общие функции для тестирования, включая describe и it.

Chai – библиотека поддерживает разнообразные функции для проверок. Есть разные «стили» проверки результатов (assert, expect, should).

>Важный момент, который не следует забывать, один тест должен проверять что-то одно. Так, если вы хотите проверить работу сервиса на разном наборе параметров одновременно, стоит их разделить на отдельные блоки. 
>>Поскольку, в случае с указанными выше средствами, если делать несколько assert в одном блоке it, то при обнаружении ошибки в первом, второй так и не выполнится, так как прекращается выполнения блока it.

[Sinon](http://sinonjs.org) – это библиотека для JavaScript, которая предоставляет функции для эмуляции и проверки требуемого поведения. В ней представлены три вида тестирования с spy, stub и mock. 

Согласно ее документации, можно заметить, что предложенное разделение коррелирует с теми возможностями проверок, которые сопровождают mock и stub в данной библиотеке:

```
let mock = sinon.mock(obj);

let expectation = mock.expects("method");
```
Например, теперь можно проверять следующее:
* expectation.atLeast(number) - минимально ожидаемое количество вызовов
* expectation.atMost(number) - максимально ожидаемое количество вызовов
* expectation.never() - не ожидается быть вызванным
* expectation.once() - ожидается быть вызванным один раз (twice - дважды, thrice - трижды)
* expectation.exactly(number) - ожидается быть вызванным строго заданное число раз
* expectation.withArgs(arg1, arg2, ...) - ожидается быть вызванным с указанными аргументами
* и др.

```
let stub = sinon.stub(object, "method");

или заменить весь объект sinon.stub(object);
```
Приведу основную идею вариативности возможностей:

	 stub.withArgs(2).returns(1);
     
     Или в случае исключительной ситуации
     
     stub.withArgs(1).throws("Error");
     
     И если вызовем, то получим
     stub(); // Ничего не возвращается, не определили поведение
     stub(2); // Вернет 1
     stub(1); // Throws Error

Если необходимая функция используется несколько раз в тестируемом блоке и должна возвращать разные объекты - можно воспользоваться

	stub.onCall(n) - есть еще onFirstCall, onSecondCall, onThirdCall

**Вывод**

Когда вы покрываете функционал Unit-тестами, стоит обратить внимание на рассматриваемые типы тестовых объектов, посколько с их помощью можно эффективно проверить многие аспекты вашего кода. Так они позволяют:
* минимизировать скорость выполнения тестов в сравнении с тестами над реальными объектами (обращение к базе данных, файловой системе и другие сторонние запросы)
* запускать тесты независимо от окружения (отсутствие данных в базе на машине разработчика, к которым обращается выполняемый код)
* не зависеть от сопроводительного интерфейса, либо серверной составляющей (удобно в случае, когда у одного из них не реализован функционал для проверки) 
* устранить сложности при проверке над реальными объектами (например, авторизация в приложении через социальную сеть с необходимостью получения токена).

Выбор stub или mock объекта зависит только от того, что необходимо проверить в том или ином тесте. 
