# CSS3: Grid layout

Некоторое время  назад мне впервые попалось описание новых возможностей CSS3 – Grid layout. На тот момент большинство браузеров еще не включило поддержку новых свойств, однако анонсировалось скорое их добавление. И вот сейчас, спустя несколько месяцев, можно пользоваться преимуществами новой системы в большинстве популярных браузеров. Мне нововведение показалось весьма интересным и актуальным, и я решила попробовать разобраться с основами его использования на практике. 
Для начала, первое впечатление от описания системы: способ организации страницы может показаться весьма непривычным, возможно даже странным и неудобным, поскольку задавать ее приходится не блоками/ячейками а линиями, в буквальном смысле выстраивая сетку. Такой подход должен быть хорошо знаком дизайнерам, привыкшим иметь дело с направляющими и модульной сеткой. И отсюда происходит первое преимущество, которое, на мой взгляд, несет в себе Grid layout: дизайнер и верстальщик могут существовать в единой системе, что порой может значительно облегчить работу последнего. А для того, чтобы привыкнуть к новым свойствам и работе с ними понадобится совсем немного времени.
При использовании Grid layout, как и при работе с flex создается основной контейнер, для которого существует свой набор свойств и дочерние объекты, со своими свойствами.
В родительском контейнере задаются линии сетки, отступы между блоками и выравнивания объектов и содержимого. Также тут могут задаваться и области, но это возможно и непосредственно в стилях дочерних элементов.
Итак, для примера я использую простую схему страницы и сверстаю ее используя Grid.
Я выбрала несложную, регулярную структуру, так что тут как раз можно обойтись одним родительским контейнером, что вполне подойдет для “быстрого старта”. 

![page-schema](./page-schema.png?raw=true)

Для родительского контейнера я создала класс .grid-container, и добавила вертикальные линии:

```css
.grid-container {
  display: grid;
  grid-template-columns: [col-start] 1fr [second-item-start] 1fr [third-item-start] 1fr [col-end];
}
```

где в квадратных скобках я указала имена линий, а после расстояние до следующей. Имена линиям можно не задавать, в этом случае обращаться к ним можно будет по индексу, который начинается с единицы, то есть [col-start] равноценно [1].
Я использую единицу измерения fr (от fraction), это значит, что все линии будут расставлены на равных расстояниях друг от друга. Мне нужны три равные колонки, и этот вариант наиболее подходящий.
Для горизонтальных линий использую пиксели и значение auto, также можно использовать проценты. Добавляю контейнеру новое свойство:

```css
grid-template-rows: [row-start] 100px [header-end content-start] auto [second-row] auto [third-row] auto [content-end footer-start] 100px [footer-end];
```

Структура такая же как и для вертикальных линий, но есть небольшое отличие: я использовала два названия через пробел для одной и той же линии, и теперь могу выбирать любое из них. Насколько на практике это может быть полезно вопрос спорный, но возможность такую система предоставляет. 
Таким образом основная сетка у меня уже есть, теперь нужно задать в ней области для дочерних элементов. Для этого предусмотрены два варианта написания стилей. Я использую более привычный и простой, на мой взгляд: задам определенному классу желаемую область. 

```css
.header {
  grid-column: col-start / col-end;
  grid-row: row-start / header-end;
}
```

Для класса header я задаю область используя имена начальной и конечной линии: область будет занимать пространство от линии col-start до линии col-end по вертикали и, аналогично по вертикали. Можно также указать, сколько промежутков (span) должна занимать область, такой способ мне удобнее использовать при создании частей контента:

```css
.top-left-square {
  grid-column: col-start / span 1;
  grid-row: content-start / span 1;
  height: 300px;
}
.top-right-area {
  grid-column: second-item-start / span 2;
  grid-row: content-start / span 1;
  height: 300px;
}
```

По аналогии задаю и все размеры для оставшихся областей.
Мой html код в данный момент выглядит следующим образом:

```html
<body>
  <div class="grid-container">
	<div class="header">header</div>
	<div class="top-left-squere">top-left-squere</div>
	<div class="top-right-area">top-right-area</div>
	<div class="center-left-square">center-left-square</div>
	<div class="center-center-square">center-center-square</div>
	<div class="center-right-square">center-right-square</div>
	<div class="bottom-left-area">bottom-left-area</div>
	<div class="bottom-right-square">bottom-right-square</div>
	<div class="footer-logo">bottom-left-area</div>
	<div class="footer-menu">bottom-right-square</div>
  </div>
</body>
```

А на странице получаю:
![page-schema](./page-table.png?raw=true)
Можно сразу добавить отступы между блоками в .grid-container используя:

```css
 grid-column-gap: 15px;
 grid-row-gap: 15px;
```

Отступы добавляются только между блоками, а внешние границы остаются на месте.

![page-schema](./page-table-border.png?raw=true)

Теперь у меня есть пустой шаблон с нужными областями, относительно независимыми друг от друга, которые можно наполнить соответствующей информацией.

![page-schema](./page-full.png?raw=true)

Причем не важно, где в HTML-коде находится каждый блок, отображаться он будет обласи заданной классами, а значит есть возможность легко изменять конфигурацию страницы. Например, чтобы поменять местами верхний левый и центральный левый блок при ширине экрана меньше 900px, достаточно медиазапроса:

```css
@media (max-width: 900px) {
  .center-left-square {
    grid-row: content-start / span 1;
  }
.top-left-square {
    grid-row: second-row / third-row;
  }
}
```

![page-schema](./page-small.png?raw=true)

Конечно, это очень упрощенный шаблон, и в реальном проекте гораздо больше нюансов, но так достаточно, чтобы получить первые впечатления: поначалу способ записи новых свойств может показаться громоздким, однако я уверена, что эта сложность на старте позволит гораздо проще работать со страницей в дальнейшем. Grid layout обладает не таким уж большим количеством свойств, часть из которых пришли сюда непосредственно из флекса, тем не менее имеет существенное концептуальное отличие, которое, вполне возможно, позволит CSS3 поспорить с некоторыми фреймворками в удобстве и гибкости верстки. И хотя я уверена, что при практическом использовании в Grid layout найдутся свои недостатки, мне безусловно хотелось бы испробовать ее на своих будущих проектах.
 
